# Code Audit: M1.4 REST API + WebSocket

**Date:** 2026-01-23  
**Scope:** `internal/api/` package + `cmd/graylogic/main.go` wiring  
**Auditor:** Claude Code (Opus 4.5)  
**Status:** COMPLETE - 14 issues fixed (6 iterations)

---

## Audit Phases

| Phase | Result | Notes |
|-------|--------|-------|
| 1. Tests + Race Detection | PASS | All tests pass, no races, 44.5% coverage (api) |
| 2. Lint Analysis | PASS | 1 new warning fixed (main.go shadow), rest pre-existing |
| 3. Vulnerability Scan | PASS | govulncheck clean, no known vulnerabilities |
| 4. AI Code Review | 8 issues | 2 critical, 3 high, 2 medium, 1 lint |
| 5. Architecture (Hard Rules) | PASS | Zero cloud deps, graceful degradation, local auth |
| 6. Dependency Stability | PASS | All deps rated Excellent for multi-decade viability |
| 7. Documentation Sync | PASS | All packages have doc.go, API spec matches impl |

---

## Issues Found and Fixed

### CRITICAL

#### 1. WebSocket Auth Bypass (empty ticket allowed)
- **File:** `websocket.go:175-181`
- **Problem:** `handleWebSocket` only validated tickets when non-empty. An empty `ticket=""` query parameter (or no parameter) bypassed authentication entirely.
- **Fix:** Split into two checks — require ticket to be present, then validate it.
- **Impact:** Unauthenticated WebSocket connections could receive all device state broadcasts.

#### 2. CleanExpiredTickets Never Called (memory leak)
- **File:** `auth.go:140-152`, `server.go:107`
- **Problem:** `CleanExpiredTickets()` existed as an exported function but was never invoked. Under sustained load, expired tickets accumulate indefinitely.
- **Fix:** Added `cleanTicketsLoop()` method on Server, started as goroutine in `Start()`. Runs every 60s (matching ticketTTL). Made function unexported since it's now internal.
- **Impact:** Memory growth proportional to WebSocket connection attempts over server lifetime.

### HIGH

#### 3. closeAll Doesn't Close Send Channels (goroutine leak)
- **File:** `websocket.go:139-150`
- **Problem:** During shutdown, `closeAll()` closed WebSocket connections but not the `client.send` channels. The `writePump` goroutine blocks forever on `<-c.send`.
- **Fix:** Added `close(client.send)` before closing the connection. WritePump detects the closed channel and exits cleanly.
- **Impact:** On shutdown, one leaked goroutine per connected WebSocket client.

#### 4. No Request Body Size Limits (DoS vector)
- **File:** `devices.go`, `auth.go` (all JSON decode paths)
- **Problem:** `json.NewDecoder(r.Body).Decode()` reads unlimited bytes. A malicious client could send a multi-GB body and exhaust server memory.
- **Fix:** Added `bodySizeLimitMiddleware` using `http.MaxBytesReader(w, r.Body, 1<<20)` (1 MB limit) to the global middleware chain.
- **Impact:** Denial-of-service via memory exhaustion.

#### 5. Missing Hub Nil Check in MQTT Handler
- **File:** `websocket.go:154-171`
- **Problem:** The MQTT subscription callback calls `s.hub.Broadcast()` but the subscription is set up in `Start()` before the hub is fully wired. A race at startup could panic.
- **Fix:** Added `if s.hub == nil { return nil }` guard at the top of the callback.
- **Impact:** Nil pointer panic if MQTT delivers a message during server startup.

### MEDIUM

#### 6. Hardcoded "knx-main" Bridge Topic
- **File:** `devices.go:266`
- **Problem:** Device commands were always routed to `graylogic/bridge/knx-main/command/{id}` regardless of which protocol bridge owns the device.
- **Fix:** Added `deriveBridgeID(dev)` helper that uses the device's `GatewayID` field (if set) or falls back to `{protocol}-main`. Now uses the actual device record fetched from the registry.
- **Impact:** Commands to non-KNX devices (DALI, Modbus) would never reach their bridge.

#### 7. Lock Ordering in WebSocket Broadcast (contention)
- **File:** `websocket.go:103-130`
- **Problem:** `Broadcast()` held `h.mu.RLock` while iterating clients and calling `client.isSubscribed()` (which acquires `client.mu.RLock`). While not a deadlock (lock ordering is consistent), it holds the hub lock during potentially-blocking channel sends.
- **Fix:** Snapshot client list under hub lock, release lock, then iterate and send. Eliminates holding hub lock during channel operations.
- **Impact:** Under high concurrency, hub lock contention could delay new client registration/unregistration.

### ITERATION 2 FINDING

#### 9. Double-Close Panic in WebSocket Cleanup
- **File:** `websocket.go:94-101` (Unregister) + `websocket.go:153` (closeAll)
- **Problem:** During shutdown, `closeAll()` closes all client send channels. If a client's `readPump` exits concurrently, its defer calls `Unregister()` which also tries to `close(client.send)` — causing a panic.
- **Fix:** Guard channel close in `Unregister()` with map membership check. Only the goroutine that successfully removes the client from the map performs the close. This ensures exactly-once semantics.
- **Impact:** Server panic during graceful shutdown with active WebSocket connections.

### ITERATION 4 FINDINGS

#### 11. Broadcast Send to Closed Channel (panic)
- **File:** `websocket.go:134-140` (Broadcast loop)
- **Problem:** After snapshotting clients and releasing the hub lock, a client could be unregistered (closing its send channel) before the broadcast send. Sending to a closed channel panics — `select` with `default` does NOT protect against this.
- **Fix:** Extracted `trySend()` method with `defer recover()` to absorb the panic. This is safe because the panic is non-fatal (client already disconnected).
- **Impact:** Server crash during broadcast when a client disconnects concurrently.
- **False positives rejected:** Finding #3 (registry cache corruption) was false — `GetDevice()` returns `DeepCopy()`. Finding #4 (hub nil race) was false — hub assignment is synchronous before subscription.

#### 12. statusWriter Missing Write() Method (logging accuracy)
- **File:** `middleware.go:128-136`
- **Problem:** `statusWriter` only overrides `WriteHeader()`. If a handler calls `Write()` without explicit `WriteHeader()`, the implicit 200 status isn't captured, causing incorrect status codes in logs.
- **Fix:** Added `Write()` method that records `http.StatusOK` if no explicit status was set.
- **Impact:** Low — only affects log accuracy, not correctness. Current handlers all use `writeJSON()` correctly.

### ITERATION 3 FINDING (Final Advisory)

#### 10. Server.Close() Doesn't Stop Background Goroutines
- **File:** `server.go:101-109` (Start) + `server.go:162-178` (Close)
- **Problem:** `Start()` launches hub and cleanTicketsLoop goroutines using the parent context. `Close()` only shuts down the HTTP server, not these goroutines. If `Close()` is called independently of the parent context cancellation (tests, programmatic restart), the goroutines leak.
- **Fix:** Create an internal cancellable context in `Start()`, store the `cancel` func on Server, and call it at the top of `Close()`. Background goroutines now exit cleanly on either parent cancellation or explicit Close().
- **Impact:** Goroutine leak in non-signal-based shutdown scenarios (tests, commissioning restarts).

### ITERATION 6 FINDINGS

#### 13. Missing ReadHeaderTimeout (Slowloris DoS)
- **File:** `server.go:126-132`
- **Problem:** The `http.Server` configuration was missing `ReadHeaderTimeout`. Without it, an attacker can send HTTP headers byte-by-byte very slowly, holding connections open indefinitely. `ReadTimeout` only applies after headers are received, leaving a Slowloris attack vector.
- **Fix:** Added `ReadHeaderTimeout: time.Duration(s.cfg.Timeouts.Read) * time.Second` to the server configuration.
- **Impact:** Critical — DoS on building automation API by exhausting server connections.

#### 14. statusWriter Multiple WriteHeader Calls
- **File:** `middleware.go:133-136`
- **Problem:** `statusWriter.WriteHeader()` didn't prevent multiple calls, potentially causing misleading log entries and Go runtime warnings about superfluous WriteHeader calls.
- **Fix:** Added `written bool` field to statusWriter. `WriteHeader()` returns early if already written. `Write()` now calls `WriteHeader(200)` if not yet written (instead of just setting the status field), ensuring consistent state.
- **Impact:** Low — only affects log accuracy and runtime warnings.
- **False positive rejected:** Finding #3 (Hub startup race) was false — `Broadcast()` is independent of `Run()`, operates via mutex on the clients map which is initialized synchronously in `NewHub()`.

### LINT

#### 8. main.go Shadow Warning
- **File:** `cmd/graylogic/main.go:161`
- **Problem:** `if err := apiServer.Start(ctx)` declared a new `err` shadowing the outer `err` from line 78.
- **Fix:** Changed `:=` to `=` to reuse the existing `err` variable.
- **Impact:** Lint warning only; no runtime bug.

---

## Architecture Review: Hard Rules Compliance

All 7 Hard Rules verified COMPLIANT:

1. **Physical controls always work** - KNX switches operate independently; API is observational
2. **Life safety is independent** - No life safety control logic in codebase
3. **No cloud dependencies** - Zero external API calls; MQTT/auth/data all local
4. **Multi-decade deployment** - All deps version-pinned, mature (5-14 years old)
5. **Open standards** - KNX, DALI, Modbus only; no proprietary protocols
6. **Customer owns system** - No licensing, activation, or dealer locks
7. **Privacy by design** - All processing local; CORS restricts to local origins

---

## Dependency Stability

All direct dependencies rated **Excellent** for multi-decade viability:

| Dependency | Age | Rating | Notes |
|-----------|-----|--------|-------|
| go-chi/chi/v5 | ~9 years | Excellent | De facto Go router standard |
| gorilla/websocket | ~14 years | Excellent | Industry gold standard, CNCF |
| golang-jwt/jwt/v5 | ~12 years | Excellent | Revitalized community, RFC-compliant |
| eclipse/paho.mqtt | ~12 years | Excellent | Eclipse Foundation, ISO standard |
| mattn/go-sqlite3 | ~12 years | Excellent | Stable C wrapper |
| stretchr/testify | ~11 years | Excellent | Test-only, minimal risk |

Notable: Project correctly uses stdlib `log/slog` instead of external logging library.

---

## Recommendations (Not Blocking)

1. **M1.5**: Replace dev credentials with real user DB + proper key management
2. **M1.6**: Enable JWT validation in auth middleware (currently pass-through)
3. **Future**: Make MQTT truly optional at startup (reconnect with backoff)
4. **Future**: Add per-client rate limiting (config already supports it)

---

## Verification

```
$ go test -race ./...                    # All pass
$ golangci-lint run ./...                # No new warnings (api package clean)
$ govulncheck ./...                      # No vulnerabilities
$ go build -o /dev/null ./cmd/graylogic  # Clean build
```
